
array:array dump = array x -> {
	int i = 0
	while i < size(x) {
		print(x[i])
		i = i + 1
	}
	return x
}

/*
array:float min = array x -> {
	float m = x[0]
	int i = 0
	while i < size(x) {
		if m > x[i] { m = x[i] }
		i = i + 1
	}
	return m
}

array:float max = array x -> {
	float m = x[0]
	int i = 0
	while i < size(x) {
		if m < x[i] { m = x[i] }
		i = i + 1
	}
	return m
}

array:array reverse = array x -> {
	int length = size(x)
	array y = new(length)
	int i = 1
	while i <= length {
		y[i - 1] = x[length - i]
		i = i + 1
	}
	return y
}

array:float integrate = array x -> {
	float sum = 0.0
	int i = 0
	while i < size(x) {
		sum = sum + x[i]
		i = i + 1
	}
	return sum
}

array:array scale = array x -> float:float lambda -> {
	float scalar = lambda(x)
	int i = 0
	while i < size(x) {
		x[i] = x[i] * scalar
		i = i + 1
	}
	return x
}

array:float inverseArrayFloat = array x -> array:float lambda -> 1 / lambda(x)

array:float inverseMax = array x -> inverseArrayFloat(x, max)

array:array normalize = array x -> scale(x, inverseMax)

array:array loop = array x -> float start -> float end -> float count -> {
	int length = floor(end - start + 1)
	int samples = floor(length * count)
	array buffer = new(samples)
	int i = 0
	int j = 0
	int offset = floor(start)
	while i < samples {
		buffer[i] = x[j % length + offset]
		i = i + 1
		j = j + 1
	}
	return buffer
}

array:array speed = array x -> float s -> {
	if s < 0.0 { s = -s }
	int samples = floor(size(x) / s)
	array buffer = new(samples)
	int i = 0
	float j = 0.0
	float x0 = 0.0
	float x1 = 0.0
	float y0 = 0.0
	float y1 = 0.0
	float length = size(x) + 0.0
	while i < samples {
		x0 = floor(j) + 0.0 /* adding zero casts to float */
		x1 = x0 + 1
		y0 = x[floor(x0)]
		y1 = x[0]
		if x1 < length { y1 = x[floor(x1)] }
		buffer[i] = y0 + (j - x0) * (y1 - y0) /* simple linear interpolation */
		i = i + 1
		j = j + s
		if j >= length { j = j - length }
	}
	return buffer
}

array:array delay = array x -> float time -> float feedback -> float wet -> {
	int length = size(x)
	array buffer = new(length)
	array circular = new(length)
	int readIndex = 0
	int writeIndex = floor(time * 44.1)
	int i = 0
	while i < length {
		buffer[i] = wet * circular[readIndex] + (1.0 - wet) * x[i]
		circular[writeIndex] = x[i] + circular[readIndex] * feedback
		i = i + 1
		readIndex = readIndex + 1
		if readIndex >= length { readIndex = 0 }
		writeIndex = writeIndex + 1
		if writeIndex >= length { writeIndex = 0 }
	}
	return buffer
}

array:array line = array breakpoints -> float length -> {
	int samples = floor(length) * (size(breakpoints) - 1)
	array buffer = new(samples)
	int index = 0
	float value = breakpoints[0]
	float increment = 0.0
	int i = 0
	while i < size(breakpoints) - 1 {
		int j = 0
		while j < floor(length) {
			if i == size(breakpoints) - 2 {
				increment = (breakpoints[i + 1] - breakpoints[i]) / (length - 1.0)
			}
			if i != size(breakpoints) - 2 {
				increment = (breakpoints[i + 1] - breakpoints[i]) / length
			}
			buffer[index] = value
			index = index + 1
			value = value + increment
			j = j + 1
		}
		i = i + 1
	}
	return buffer
}

array:array fadeIn = array x -> array fade -> {
	int samples = size(fade)
	array buffer = new(size(x))
	int i = 0
	while i < size(x) {
		buffer[i] = x[i]
		if i < samples { buffer[i] = buffer[i] * fade[i] }
		i = i + 1
	}
	return buffer
}

array:array fadeOut = array x -> array fade -> {
	int samples = size(fade)
	array buffer = new(size(x))
	int i = 0
	int j = 0
	while i < size(x) {
		buffer[i] = x[i]
		if i >= size(x) - samples {
			buffer[i] = buffer[i] * fade[j]
			j = j + 1
		}
		i = i + 1
	}
	return buffer
}

array:array crossFade =
	array first ->
	array second ->
	array:array inFadeIn ->
	array:array inFadeOut ->
	float overlap -> {
	int offset = size(first) - floor(overlap)
	array buffer = new(size(second) + offset)
	array buffer1 = inFadeOut(first)
	array buffer2 = inFadeIn(second)
	int i = 0
	while i < size(first) {
		buffer[i] = buffer1[i]
		i = i + 1
	}
	i = 0
	while i < size(second) {
		buffer[i + offset] = buffer[i + offset] + buffer2[i]
		i = i + 1
	}
	return buffer
}

array:array mix = array first -> array second -> {
	int samples = size(first)
	if size(second) < size(first) { samples = size(second) }
	array buffer = new(samples)
	int i = 0
	while i < samples {
		buffer[i] = first[i] + second[i]
		i = i + 1
	}
	return buffer
}

array:array splice = array first -> array second -> {
	int samples = size(first) + size(second)
	array buffer = new(samples)
	int i = 0
	int j = 0
	while i < samples {
		if i < size(first) { buffer[i] = first[i] }
		if i >= size(first) {
			buffer[i] = second[j]
			j = j + 1
		}
		i = i + 1
	}
	return buffer
}

import("doc/Lambdas.scandal")
import("doc/Prelude.scandal")
*/
